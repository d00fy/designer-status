{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/slider.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uGAAuG,0NAA0N;AACjU;AACA,0FAA0F,0NAA0N;AACpT;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;;AAEA;AACA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA,SAAS;AACT;;;;AAIA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,2CAA2C;;AAE/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA,SAAS;AACT;;;;AAIA,CAAC,E","file":"slider.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/slider.js\");\n","//----------------------------------------//\n//  GLOBAL VARS\n//----------------------------------------//\n\n// Lower track color\nvar rangeSliderTrackColor = '#ccc',\n    // Upper track color\n    rangeSliderTrackFillColor = 'skyblue',\n\n    // ID of the HTML style element that gets appended to the HTML head\n    rangeSliderStyleElementID = 'rangeSliderStyleElement',\n\n    // Class that gets assigned to the individual range sliders (+ ongoing index number)\n    rangeSliderClass = 'range-slider__input--',\n\n    // A variable to call every instance of range sliders\n    $rangeSliderElement = document.querySelectorAll('.range-slider input[type=range]'),\n\n    // A variable to call every instance of dotted range sliders\n    $dottedRangeSliderElement = document.querySelectorAll('.range-slider--dotted input[type=range]');\n\n\n\n\n\n//----------------------------------------//\n//  FUNCTIONS\n//----------------------------------------//\n\n// Function to create empty style elements in the HTML head \n// to append the dynamic syles for the range sliders to\nfunction createStyleElements(numberOfStyleElements) {\n    // We want a <style> element\n    var rangeSliderStyleElement = document.createElement('style');\n    // ...equal the amount of range sliders on the side\n    rangeSliderStyleElement.id = rangeSliderStyleElementID + numberOfStyleElements;\n    // ...and append it to the HTML head\n    document.head.appendChild(rangeSliderStyleElement);\n}\n\n\n\n// Function that takes care of coloring the range slider track differently\n// on the left and on the right side of the slider handle.\nfunction paintRangeTrack(rangeSliderInstance) {\n    // Get the current value of the actual range slider\n    var rangeValue = $rangeSliderElement[rangeSliderInstance].value,\n        // Get the max attributes value of the actual range slider\n        rangeMaxValue = $rangeSliderElement[rangeSliderInstance].getAttribute('max');\n\n    // Generate the CSS and put it into the style tag with the appropriate ID in the HTML head\n    // (One for Webkit, one for Firefox)    \n    document.getElementById(rangeSliderStyleElementID + rangeSliderInstance).textContent =\n        'input[class~=\"' + rangeSliderClass + rangeSliderInstance + '\"]::-webkit-slider-runnable-track{background: linear-gradient(90deg, ' + rangeSliderTrackFillColor + ' ' + Math.round((rangeValue / rangeMaxValue) * 100) + '% , ' + rangeSliderTrackColor + ' ' + Math.round((rangeValue / rangeMaxValue) * 100 + 1) + '%)}'\n        +\n        'input[class~=\"' + rangeSliderClass + rangeSliderInstance + '\"]::-moz-range-track{background: linear-gradient(90deg, ' + rangeSliderTrackFillColor + ' ' + Math.round((rangeValue / rangeMaxValue) * 100) + '% , ' + rangeSliderTrackColor + ' ' + Math.round((rangeValue / rangeMaxValue) * 100 + 1) + '%)}'\n        ;\n}\n\n\n\n// Function to generate the correct amount dots for dotted range sliders\nfunction createRangeSliderDots(dottedRangeSliderInstance) {\n    // Get the min value of the actual range slider\n    var rangeSliderMinValue = $dottedRangeSliderElement[dottedRangeSliderInstance].getAttribute('min'),\n        // Get the max value of the actual range slider\n        rangeSliderMaxValue = $dottedRangeSliderElement[dottedRangeSliderInstance].getAttribute('max'),\n        // Calculate the correct number of steps thereof\n        rangeSliderDots = rangeSliderMaxValue - rangeSliderMinValue + 1,\n        // Get the container to put the dot elements into\n        $rangeSliderStepsContainer = document.querySelectorAll('.range-slider__dots');\n\n    // Iterate over the amount of the actual needed dots\n    for (var i = 0; i < rangeSliderDots; i++) {\n        // We want to create span elements representing the dots\n        var rangeSliderDotElement = document.createElement('span');\n\n        // Append the span to the dots container\n        $rangeSliderStepsContainer[dottedRangeSliderInstance].appendChild(rangeSliderDotElement);\n    }\n}\n\n\n\n// Function to generate the necessary container for the dots of the dotted range slider\nfunction createDotsContainerElement() {\n\n    // For every dotted range slider...    \n    Array.prototype.forEach.call(document.querySelectorAll('.range-slider--dotted'), function (el, i) {\n        // ...we want a <div> element\n        var dotsContainerElement = document.createElement('div');\n\n        // ...with a class of 'range-slider__dots`\n        dotsContainerElement.className = 'range-slider__dots';\n\n        // ...and append it to the actual range slider\n        el.appendChild(dotsContainerElement);\n    });\n\n}\n\n\n\n// Function to paint the slider dots in the correct color\nfunction paintSliderDots(dottedRangeSliderInstance) {\n    // Get the current value of the actual range slider    \n    var rangeSliderValue = $dottedRangeSliderElement[dottedRangeSliderInstance].value,\n        // Collect all dots from the actual dotted slider\n        rangeSliderDots = $dottedRangeSliderElement[dottedRangeSliderInstance].parentNode.querySelectorAll('.range-slider__dots span');\n\n    // Iterate over all dots of this respective dotted range slider\n    for (var j = 0; j < rangeSliderDots.length; j++) {\n        // If the dot is lower than the sliders current value...\n        if (j < rangeSliderValue) {\n            // ...paint it in the lower slider tracks color\n            rangeSliderDots[j].style.backgroundColor = rangeSliderTrackFillColor;\n            // If it's greater than the current sliders value...\n        } else {\n            // ...paint it in the upper slider tracks color\n            rangeSliderDots[j].style.backgroundColor = rangeSliderTrackColor;\n        }\n    }\n}\n\n\n\n\n\n//----------------------------------------//\n//  DOM-READY FUNCTION\n//----------------------------------------//\n\ndocument.addEventListener('DOMContentLoaded', function (event) {\n\n\n\n    // NORMAL RANGE SLIDERS    \n\n    // Get all range sliders on the page\n    var sliders = $rangeSliderElement;\n\n    // Iterate over all range sliders on the page\n    for (var rangeSliders = 0; rangeSliders < sliders.length; rangeSliders++) {\n        // Create an empty style element for each range slider \n        // in the hmtl head and give each one an unique id.\n        createStyleElements(rangeSliders);\n\n        // Give each range slider an unique class\n        $rangeSliderElement[rangeSliders].classList.add(rangeSliderClass + rangeSliders);\n\n        // Fill the lower and upper end of the range slider track with the correct color\n        paintRangeTrack(rangeSliders);\n\n        // On-change function, so the filled area \n        // changes dynamically with the current sliders value   \n        sliders[rangeSliders].addEventListener('input', function () {\n            // Iterate over all range sliders on the page\n            for (var i = 0; i < sliders.length; i++) {\n                // Fill the lower and upper end of the range slider track with the correct color\n                paintRangeTrack(i);\n            }\n        })\n    }\n\n\n\n    // DOTTED RANGE SLIDERS    \n\n    // Get all dotted range sliders on the page\n    var dottedSliders = $dottedRangeSliderElement;\n\n    // Create the dots container element\n    createDotsContainerElement();\n\n    // Iterate over all range sliders on the page\n    for (var dottedRangeSliders = 0; dottedRangeSliders < dottedSliders.length; dottedRangeSliders++) {\n\n        // Create the dots\n        createRangeSliderDots(dottedRangeSliders);\n\n        // ...and paint them appropriately\n        paintSliderDots(dottedRangeSliders);\n\n        // Add event listener (when the user changes the value)\n        dottedSliders[dottedRangeSliders].addEventListener('input', function () {\n            // Iterate over all range dotted sliders on the page\n            for (var i = 0; i < dottedSliders.length; i++) {\n                // ...and paint them correctly on change\n                paintSliderDots(i);\n            }\n        })\n\n        // Add an additional event listener ('mousemove') for IE\n        // (IE seems to have a problem with the 'input' event listeners on range sliders)\n        dottedSliders[dottedRangeSliders].addEventListener('mousemove', function () {\n            // Iterate over all range dotted sliders on the page\n            for (var i = 0; i < dottedSliders.length; i++) {\n                // ...and paint them correctly on change\n                paintSliderDots(i);\n            }\n        })\n    }\n\n\n\n});"],"sourceRoot":""}